name: Auto Release on Main Push

on:
  push:
    branches: [ main ]

jobs:
  test:
    name: Run Tests Before Release
    uses: ./.github/workflows/test.yml

  auto-release:
    name: Automatic Versioning and Release
    runs-on: ubuntu-latest
    needs: test
    # Skip if commit is from auto-release workflow to prevent infinite loop
    if: "!contains(github.event.head_commit.message, '[skip-workflow]') && !contains(github.event.head_commit.message, '[auto-release-skip]')"

    permissions:
      contents: write
      id-token: write
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for version calculation
          
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install build twine wheel setuptools toml packaging
          
      - name: Extract current version from pyproject.toml
        id: extract_version
        run: |
          # Extract version using Python to ensure accuracy
          CURRENT_VERSION=$(python -c "import toml; print(toml.load('pyproject.toml')['project']['version'])")
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version in pyproject.toml: $CURRENT_VERSION"
          
      - name: Check if version changed in current commit
        id: version_changed
        run: |
          # Check if pyproject.toml version line changed in current commit
          if git show HEAD --name-only | grep -q "pyproject.toml"; then
            # pyproject.toml was modified, check if version line specifically changed
            if git show HEAD -- pyproject.toml | grep -E "^[+-].*version.*="; then
              echo "version_changed=true" >> $GITHUB_OUTPUT
              echo "Version changed in current commit"
            else
              echo "version_changed=false" >> $GITHUB_OUTPUT
              echo "pyproject.toml changed but version line unchanged"
            fi
          else
            echo "version_changed=false" >> $GITHUB_OUTPUT
            echo "pyproject.toml not modified in current commit"
          fi
          
      - name: Calculate dev version if needed
        id: calculate_version
        run: |
          CURRENT_VERSION="${{ steps.extract_version.outputs.current_version }}"
          VERSION_CHANGED="${{ steps.version_changed.outputs.version_changed }}"
          
          if [ "$VERSION_CHANGED" = "true" ]; then
            # Use the version from pyproject.toml as-is (real release)
            FINAL_VERSION="$CURRENT_VERSION"
            RELEASE_TYPE="release"
            echo "Using real release version: $FINAL_VERSION"
          else
            # Generate dev version
            # Find the LAST commit where current version was set (most recent)
            VERSION_COMMIT=$(git log --oneline -p -- pyproject.toml | grep -B1 "+version = \"$CURRENT_VERSION\"" | head -1 | grep "^[a-f0-9]" | cut -d' ' -f1)

            if [ -z "$VERSION_COMMIT" ]; then
              # Fallback: find any commit that mentions this version
              VERSION_COMMIT=$(git log --oneline --grep="$CURRENT_VERSION" | head -1 | cut -d' ' -f1)
            fi

            if [ -z "$VERSION_COMMIT" ]; then
              # Ultimate fallback: count from first commit
              DEV_NUMBER=$(git rev-list --count HEAD)
              echo "[FALLBACK] No version history found, counting all commits: $DEV_NUMBER"
            else
              # Count commits AFTER the version was set (this is the key fix)
              DEV_NUMBER=$(git rev-list --count ${VERSION_COMMIT}..HEAD)
              echo "[INFO] Found $DEV_NUMBER commits since version $CURRENT_VERSION was last set ($VERSION_COMMIT)"

              # If no commits since version was set, this means we're at the release commit
              if [ "$DEV_NUMBER" -eq 0 ]; then
                # We're at the exact release commit, no dev version needed
                FINAL_VERSION="$CURRENT_VERSION"
                RELEASE_TYPE="release"
                echo "[INFO] At release commit, using version as-is: $FINAL_VERSION"
                echo "final_version=$FINAL_VERSION" >> $GITHUB_OUTPUT
                echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
                echo "Final version: $FINAL_VERSION (type: $RELEASE_TYPE)"
                exit 0
              fi
            fi
            
            FINAL_VERSION="${CURRENT_VERSION}.dev${DEV_NUMBER}"
            RELEASE_TYPE="prerelease"
            echo "Generated dev version: $FINAL_VERSION"
          fi
          
          echo "final_version=$FINAL_VERSION" >> $GITHUB_OUTPUT
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "Final version: $FINAL_VERSION (type: $RELEASE_TYPE)"
          
      - name: Update pyproject.toml with final version
        run: |
          FINAL_VERSION="${{ steps.calculate_version.outputs.final_version }}"

          # Create Python script to update version
          cat > update_version.py << 'EOF'
          import toml
          import sys
          import os

          final_version = os.environ['FINAL_VERSION']

          # Read current pyproject.toml
          with open('pyproject.toml', 'r') as f:
              data = toml.load(f)

          # Update version
          data['project']['version'] = final_version

          # Write back to file
          with open('pyproject.toml', 'w') as f:
              toml.dump(data, f)

          print(f'Updated pyproject.toml version to: {final_version}')
          EOF

          # Run the update script
          FINAL_VERSION="$FINAL_VERSION" python update_version.py

          # Verify the update
          UPDATED_VERSION=$(python -c "import toml; print(toml.load('pyproject.toml')['project']['version'])")
          echo "Verified updated version: $UPDATED_VERSION"

          # Clean up
          rm update_version.py

      - name: Update README.md with dynamic version, status, and test results
        run: |
          FINAL_VERSION="${{ steps.calculate_version.outputs.final_version }}"
          TEST_PASSED="${{ needs.test.outputs.test-passed }}"
          TEST_FAILED="${{ needs.test.outputs.test-failed }}"
          TEST_ERROR="${{ needs.test.outputs.test-error }}"
          TEST_TOTAL="${{ needs.test.outputs.test-total }}"
          TEST_SUMMARY="${{ needs.test.outputs.test-summary }}"

          # Create Python script with persistent marker system
          cat > update_readme.py << 'EOF'
          import re
          import os
          from datetime import datetime

          def calculate_status(version_str: str) -> str:
              """Calculate status based on version ranges."""
              # Remove dev suffix for status calculation
              clean_version = re.sub(r'\.dev\d+$', '', version_str)

              # Parse version components
              parts = clean_version.split('.')
              major = int(parts[0]) if len(parts) > 0 else 0
              minor = int(parts[1]) if len(parts) > 1 else 0

              if major == 0 and minor < 5:
                  return "Alpha"
              elif major == 0 and minor < 10:
                  return "Beta"
              elif major < 1:
                  return "Release Candidate"
              else:
                  return "Stable Release"

          def get_disclaimer_note(status: str) -> str:
              """Generate appropriate disclaimer note based on status."""
              if status == "Alpha":
                  return "> **Note**: This software is currently in alpha development. APIs may change."
              elif status == "Beta":
                  return "> **Note**: This software is in beta. Some features may be unstable. APIs may change."
              elif status == "Release Candidate":
                  return "> **Note**: This software is a release candidate. Please report any issues."
              else:  # Stable Release
                  return "> **Note**: This software is stable and production-ready."

          def format_test_results(passed, failed, error, total, summary):
              """Format test results using actual pytest summary."""
              # If we have a summary from pytest, use it directly
              if summary and summary.strip() and summary != "Tests failed":
                  return summary.strip()

              # Fallback to old format if no summary available
              if not passed and not failed and not error and not total:
                  return "⏳ Running tests..."

              parts = []
              if passed > 0:
                  parts.append(f"✅ {passed} passed")
              if failed > 0:
                  parts.append(f"❌ {failed} failed")
              if error > 0:
                  parts.append(f"⚠️ {error} error")

              if not parts:
                  return "⏳ No test results"

              return ", ".join(parts)

          # Get values from environment
          final_version = os.environ['FINAL_VERSION']
          status = calculate_status(final_version)
          disclaimer = get_disclaimer_note(status)

          # Get test results (with fallbacks)
          try:
              test_passed = int(os.environ.get('TEST_PASSED', '0'))
              test_failed = int(os.environ.get('TEST_FAILED', '0'))
              test_error = int(os.environ.get('TEST_ERROR', '0'))
              test_total = int(os.environ.get('TEST_TOTAL', '0'))
          except (ValueError, TypeError):
              test_passed = test_failed = test_error = test_total = 0

          test_summary = os.environ.get('TEST_SUMMARY', '')
          test_results = format_test_results(test_passed, test_failed, test_error, test_total, test_summary)
          timestamp = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')

          # Read README.md
          with open('README.md', 'r', encoding='utf-8') as f:
              content = f.read()

          # Create the replacement content
          replacement_content = (
              "<!-- KUZUALCHEMY-AUTO-UPDATE-START -->\n"
              f"# Version: {final_version}\n\n"
              f"**Status**: {status}\n\n"
              f"**Tests**: {test_results} (Last updated: {timestamp})\n\n"
              "[![Tests](https://github.com/FanaticPythoner/kuzualchemy/actions/workflows/test.yml/badge.svg)](https://github.com/FanaticPythoner/kuzualchemy/actions/workflows/test.yml)\n"
              "[![PyPI version](https://badge.fury.io/py/kuzualchemy.svg)](https://badge.fury.io/py/kuzualchemy)\n"
              "[![Python versions](https://img.shields.io/pypi/pyversions/kuzualchemy.svg)](https://pypi.org/project/kuzualchemy/)\n\n"
              "KuzuAlchemy is an Object-Relational Mapping (ORM) library for the [Kuzu graph database](https://kuzudb.com/). It provides a SQLAlchemy-like interface for working with graph data.\n\n"
              f"{disclaimer}\n"
              "<!-- KUZUALCHEMY-AUTO-UPDATE-END -->"
          )

          # Use persistent marker system
          marker_pattern = r'<!-- KUZUALCHEMY-AUTO-UPDATE-START -->.*?<!-- KUZUALCHEMY-AUTO-UPDATE-END -->'

          if re.search(marker_pattern, content, re.DOTALL):
              # Markers exist, replace content between them
              content = re.sub(marker_pattern, replacement_content, content, flags=re.DOTALL)
              print(f'Updated existing markers in README.md')
          else:
              # Markers don't exist, add them after the third line
              lines = content.split('\n')
              if len(lines) >= 3:
                  lines.insert(4, '')  # Add blank line
                  lines.insert(5, replacement_content)
                  lines.insert(6, '')  # Add blank line
                  content = '\n'.join(lines)
                  print(f'Added new markers to README.md')
              else:
                  # Fallback: append at the end
                  content += '\n\n' + replacement_content + '\n'
                  print(f'Appended markers to end of README.md')

          # Write back to README.md
          with open('README.md', 'w', encoding='utf-8') as f:
              f.write(content)

          print(f'README.md updated successfully:')
          print(f'  Version: {final_version}')
          print(f'  Status: {status}')
          print(f'  Tests: {test_results}')
          print(f'  Disclaimer: {disclaimer}')
          print(f'  Timestamp: {timestamp}')
          EOF

          # Run the update script
          FINAL_VERSION="$FINAL_VERSION" \
          TEST_PASSED="$TEST_PASSED" \
          TEST_FAILED="$TEST_FAILED" \
          TEST_ERROR="$TEST_ERROR" \
          TEST_TOTAL="$TEST_TOTAL" \
          TEST_SUMMARY="$TEST_SUMMARY" \
          python update_readme.py

          # Verify the update
          echo "README.md updated with persistent markers:"
          grep -A 5 -B 1 "KUZUALCHEMY-AUTO-UPDATE" README.md || echo "Markers not found"

          # Clean up
          rm update_readme.py

      - name: Commit updated README.md
        run: |
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Check if README.md was actually changed
          if git diff --quiet README.md; then
            echo "README.md unchanged, skipping commit"
          else
            echo "README.md changed, committing update"
            git add README.md

            # Use a commit message that will be excluded by the workflow trigger
            git commit -m "chore: update README.md with version ${{ steps.calculate_version.outputs.final_version }} [skip-workflow]

            - Version: ${{ steps.calculate_version.outputs.final_version }}
            - Status: Auto-calculated based on version ranges
            - Updated by: GitHub Actions auto-release workflow"

            # Only push if not in local testing
            if [[ "${{ github.actor }}" != "nektos/act" ]] && [[ -n "${{ secrets.GITHUB_TOKEN }}" ]]; then
              git push origin main
              echo "README.md committed and pushed"
            else
              echo "Skipping git push (local testing environment)"
            fi
          fi


      - name: Build package
        run: |
          python -m build
          
      - name: Verify built artifacts
        run: |
          twine check dist/*
          ls -la dist/
          
      - name: Create GitHub Release
        run: |
          # Skip release creation in local testing environment
          if [[ "${{ github.actor }}" == "nektos/act" ]] || [[ -z "${{ secrets.GITHUB_TOKEN }}" ]]; then
            echo "Skipping GitHub release creation (local testing or missing token)"
            echo "Would create release: v${{ steps.calculate_version.outputs.final_version }}"
            exit 0
          fi

          # Create release using GitHub CLI (modern approach)
          RELEASE_TYPE="${{ steps.calculate_version.outputs.release_type }}"
          VERSION="v${{ steps.calculate_version.outputs.final_version }}"

          PRERELEASE_FLAG=""
          if [[ "$RELEASE_TYPE" == "prerelease" ]]; then
            PRERELEASE_FLAG="--prerelease"
          fi

          gh release create "$VERSION" \
            --title "Release $VERSION" \
            --notes "Automatic release for version ${{ steps.calculate_version.outputs.final_version }}

          **Release Type**: ${{ steps.calculate_version.outputs.release_type }}
          **Commit**: ${{ github.sha }}
          **Branch**: ${{ github.ref_name }}

          This release was automatically generated from commit ${{ github.sha }}." \
            $PRERELEASE_FLAG \
            --repo ${{ github.repository }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Publish package to PyPI
        run: |
          # Skip PyPI publishing in local testing environment
          if [[ "${{ github.actor }}" == "nektos/act" ]] || [[ -z "${{ secrets.PYPI_API_TOKEN }}" ]]; then
            echo "Skipping PyPI publishing (local testing or missing token)"
            echo "Would publish: kuzualchemy==${{ steps.calculate_version.outputs.final_version }}"
            echo "Built packages:"
            ls -la dist/
            exit 0
          fi

          # Publish to PyPI using twine (more reliable than action for complex cases)
          python -m pip install --upgrade twine
          python -m twine upload dist/* --verbose
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
          
      - name: Upload build artifacts (local testing check)
        run: |
          # Skip artifact upload in local testing environment
          if [[ "${{ github.actor }}" == "nektos/act" ]] || [[ -z "${{ env.ACTIONS_RUNTIME_TOKEN }}" ]]; then
            echo "Skipping artifact upload (local testing environment)"
            echo "Would upload artifacts:"
            ls -la dist/
            echo "Artifact name would be: dist-${{ steps.calculate_version.outputs.final_version }}"
            exit 0
          fi

          echo "Production environment detected, artifacts will be uploaded by next step"

      - name: Upload build artifacts (production only)
        if: github.actor != 'nektos/act' && env.ACTIONS_RUNTIME_TOKEN != ''
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ steps.calculate_version.outputs.final_version }}
          path: dist/
          retention-days: 30
          
      - name: Summary
        run: |
          echo "## Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ steps.calculate_version.outputs.final_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Type**: ${{ steps.calculate_version.outputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **PyPI**: Published with skip-existing" >> $GITHUB_STEP_SUMMARY
          echo "- **GitHub Release**: Created" >> $GITHUB_STEP_SUMMARY
