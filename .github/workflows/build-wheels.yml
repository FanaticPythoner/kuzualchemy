# SPDX-FileCopyrightText: 2025 FanaticPythoner
# SPDX-License-Identifier: Apache-2.0

name: Build Multi-Platform Python Wheels

on:
  workflow_call:
    inputs:
      version:
        description: 'Version to build (optional, will extract from pyproject.toml if not provided)'
        required: false
        type: string
      upload_artifacts:
        description: 'Whether to upload build artifacts'
        required: false
        type: boolean
        default: true
      artifact_name_suffix:
        description: 'Suffix for artifact name (optional)'
        required: false
        type: string
        default: ''
      build_sdist:
        description: 'Whether to build source distribution'
        required: false
        type: boolean
        default: true
      build_wheels:
        description: 'Whether to build wheels'
        required: false
        type: boolean
        default: true
    outputs:
      version:
        description: "Version that was built"
        value: ${{ jobs.build-sdist.outputs.version }}
      sdist_path:
        description: "Path to the built source distribution"
        value: ${{ jobs.build-sdist.outputs.sdist_path }}
      artifact_name:
        description: "Name of the uploaded artifact"
        value: ${{ jobs.build-sdist.outputs.artifact_name }}
      wheels_built:
        description: "Number of wheels built"
        value: ${{ jobs.build-wheels.outputs.wheels_built }}

jobs:
  # @@ STEP 1: Build source distribution (sdist) - platform independent
  build-sdist:
    name: Build Source Distribution
    runs-on: ubuntu-latest
    if: inputs.build_sdist

    outputs:
      version: ${{ steps.extract_version.outputs.version }}
      sdist_path: ${{ steps.build_info.outputs.sdist_path }}
      artifact_name: ${{ steps.build_info.outputs.artifact_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for proper version detection

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install build twine wheel setuptools toml packaging

      - name: Extract version from pyproject.toml or use input
        id: extract_version
        run: |
          if [ -n "${{ inputs.version }}" ]; then
            VERSION="${{ inputs.version }}"
            echo "Using input version: $VERSION"
          else
            # Extract version using Python to ensure accuracy
            VERSION=$(python -c "import toml; print(toml.load('pyproject.toml')['project']['version'])")
            echo "Extracted version from pyproject.toml: $VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Update pyproject.toml with target version (if different)
        run: |
          TARGET_VERSION="${{ inputs.version }}"
          CURRENT_VERSION="${{ steps.extract_version.outputs.version }}"

          if [ -n "$TARGET_VERSION" ] && [ "$TARGET_VERSION" != "$CURRENT_VERSION" ]; then
            echo "Updating pyproject.toml version from $CURRENT_VERSION to $TARGET_VERSION"

            # || S.S. Create Python script to update version atomically
            cat > update_version.py << 'EOF'
          import toml
          import sys
          import os

          target_version = os.environ['TARGET_VERSION']

          # Read current pyproject.toml
          with open('pyproject.toml', 'r') as f:
              data = toml.load(f)

          # Update version
          data['project']['version'] = target_version

          # Write back to file
          with open('pyproject.toml', 'w') as f:
              toml.dump(data, f)

          print(f'Updated pyproject.toml version to: {target_version}')
          EOF

            # Run the update script
            TARGET_VERSION="$TARGET_VERSION" python update_version.py

            # Verify the update
            UPDATED_VERSION=$(python -c "import toml; print(toml.load('pyproject.toml')['project']['version'])")
            echo "Verified updated version: $UPDATED_VERSION"

            # Clean up
            rm update_version.py
          else
            echo "No version update needed (current: $CURRENT_VERSION)"
          fi

      - name: Build source distribution only
        run: |
          echo "Building Python source distribution..."
          # || S.S. Build only sdist, wheels will be built separately
          python -m build --sdist --verbose

      - name: Verify built source distribution
        run: |
          echo "Verifying built source distribution with twine..."
          python -m twine check dist/*.tar.gz

          echo "Built source distribution:"
          ls -la dist/

      - name: Extract build information
        id: build_info
        run: |
          VERSION="${{ steps.extract_version.outputs.version }}"

          # Find the built source distribution
          SDIST_FILE=$(find dist/ -name "*.tar.gz" | head -1)

          if [ -z "$SDIST_FILE" ]; then
            echo "ERROR: No source distribution found in dist/"
            exit 1
          fi

          echo "sdist_path=$SDIST_FILE" >> $GITHUB_OUTPUT

          # Generate artifact name
          SUFFIX="${{ inputs.artifact_name_suffix }}"
          if [ -n "$SUFFIX" ]; then
            ARTIFACT_NAME="sdist-${VERSION}-${SUFFIX}"
          else
            ARTIFACT_NAME="sdist-${VERSION}"
          fi

          echo "artifact_name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT

          echo "Build information:"
          echo "  Version: $VERSION"
          echo "  Source: $SDIST_FILE"
          echo "  Artifact name: $ARTIFACT_NAME"

      - name: Upload source distribution artifacts (internal)
        if: inputs.upload_artifacts && github.actor != 'nektos/act'
        uses: actions/upload-artifact@v4
        with:
          name: .internal-sdist-${{ steps.extract_version.outputs.version }}${{ inputs.artifact_name_suffix && format('-{0}', inputs.artifact_name_suffix) || '' }}
          path: dist/*.tar.gz
          retention-days: 1
          compression-level: 6

      - name: Build summary
        run: |
          VERSION="${{ steps.extract_version.outputs.version }}"
          SDIST_PATH="${{ steps.build_info.outputs.sdist_path }}"
          ARTIFACT_NAME="${{ steps.build_info.outputs.artifact_name }}"

          echo "## Source Distribution Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- **Source Distribution**: $SDIST_PATH" >> $GITHUB_STEP_SUMMARY
          echo "- **Artifact Name**: $ARTIFACT_NAME" >> $GITHUB_STEP_SUMMARY

  # @@ STEP 2: Build wheels for all supported platforms and Python versions
  build-wheels:
    name: Build wheels on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    if: inputs.build_wheels && github.actor != 'nektos/act'
    strategy:
      fail-fast: false
      matrix:
        # || S.S. Comprehensive OS matrix in ALPHABETICAL order
        os: [macos-latest, ubuntu-latest, windows-latest]

    outputs:
      wheels_built: ${{ steps.count_wheels.outputs.count }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for proper version detection

      - name: Extract version from pyproject.toml or use input
        id: extract_version
        run: |
          if [ -n "${{ inputs.version }}" ]; then
            VERSION="${{ inputs.version }}"
            echo "Using input version: $VERSION"
          else
            # Extract version using Python to ensure accuracy
            VERSION=$(python -c "import toml; print(toml.load('pyproject.toml')['project']['version'])")
            echo "Extracted version from pyproject.toml: $VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building wheels for version: $VERSION"
        shell: bash

      - name: Update pyproject.toml with target version (if different)
        run: |
          TARGET_VERSION="${{ inputs.version }}"
          CURRENT_VERSION="${{ steps.extract_version.outputs.version }}"

          if [ -n "$TARGET_VERSION" ] && [ "$TARGET_VERSION" != "$CURRENT_VERSION" ]; then
            echo "Updating pyproject.toml version from $CURRENT_VERSION to $TARGET_VERSION"

            # || S.S. Create Python script to update version atomically
            cat > update_version.py << 'EOF'
          import toml
          import sys
          import os

          target_version = os.environ['TARGET_VERSION']

          # Read current pyproject.toml
          with open('pyproject.toml', 'r') as f:
              data = toml.load(f)

          # Update version
          data['project']['version'] = target_version

          # Write back to file
          with open('pyproject.toml', 'w') as f:
              toml.dump(data, f)

          print(f'Updated pyproject.toml version to: {target_version}')
          EOF

            # Run the update script
            TARGET_VERSION="$TARGET_VERSION" python update_version.py

            # Verify the update
            UPDATED_VERSION=$(python -c "import toml; print(toml.load('pyproject.toml')['project']['version'])")
            echo "Verified updated version: $UPDATED_VERSION"

            # Clean up
            rm update_version.py
          else
            echo "No version update needed (current: $CURRENT_VERSION)"
          fi
        shell: bash

      - name: Set up QEMU (for Linux ARM builds)
        if: runner.os == 'Linux' && github.actor != 'nektos/act'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: all

      - name: Build wheels with cibuildwheel
        uses: pypa/cibuildwheel@v2.21.3
        env:
          # || S.S. Comprehensive cibuildwheel configuration - Python versions ORDERED from OLDEST to NEWEST
          CIBW_BUILD: "cp38-* cp39-* cp310-* cp311-* cp312-* cp313-*"

          # @@ STEP 2.1: Platform-specific configurations - Architectures in ALPHABETICAL order
          # Linux: Build for aarch64 (ARM64) and x86_64 (Intel/AMD)
          CIBW_ARCHS_LINUX: ${{ github.actor == 'nektos/act' && 'x86_64' || 'aarch64 x86_64' }}
          # Windows: Build for AMD64 (x86_64) and x86 (32-bit) - ordered by capability
          CIBW_ARCHS_WINDOWS: "AMD64 x86"
          # macOS: Build for arm64 (Apple Silicon) and x86_64 (Intel) - alphabetical
          CIBW_ARCHS_MACOS: "arm64 x86_64"

          # @@ STEP 2.2: Skip problematic combinations
          CIBW_SKIP: >
            *-musllinux_*
            pp*
            cp36-*
            cp37-*

          # @@ STEP 2.3: Test configuration
          CIBW_TEST_REQUIRES: "pytest pytest-asyncio pytest-cov pytest-mock"
          CIBW_TEST_COMMAND: "python -m pytest {project}/tests -v --tb=short || true"

          # @@ STEP 2.4: Build configuration
          CIBW_BUILD_VERBOSITY: 1

          # @@ STEP 2.5: Environment variables for build
          CIBW_ENVIRONMENT: >
            PIP_PREFER_BINARY=1
            PIP_ONLY_BINARY=":all:"

      - name: Verify built wheels
        run: |
          echo "Verifying built wheels with twine..."
          python -m pip install twine
          python -m twine check wheelhouse/*.whl

          echo "Built wheels:"
          ls -la wheelhouse/
        shell: bash

      - name: Count built wheels
        id: count_wheels
        run: |
          WHEEL_COUNT=$(find wheelhouse/ -name "*.whl" | wc -l)
          echo "count=$WHEEL_COUNT" >> $GITHUB_OUTPUT
          echo "Built $WHEEL_COUNT wheels on ${{ matrix.os }}"
        shell: bash

      - name: Upload wheel artifacts (internal)
        if: inputs.upload_artifacts && github.actor != 'nektos/act'
        uses: actions/upload-artifact@v4
        with:
          name: .internal-wheels-${{ matrix.os }}-${{ steps.extract_version.outputs.version }}${{ inputs.artifact_name_suffix && format('-{0}', inputs.artifact_name_suffix) || '' }}
          path: wheelhouse/*.whl
          retention-days: 1
          compression-level: 6

      - name: Wheel build summary
        run: |
          VERSION="${{ steps.extract_version.outputs.version }}"
          WHEEL_COUNT="${{ steps.count_wheels.outputs.count }}"

          echo "## Wheel Build Summary (${{ matrix.os }})" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- **Platform**: ${{ matrix.os }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Wheels Built**: $WHEEL_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- **Wheels Location**: wheelhouse/" >> $GITHUB_STEP_SUMMARY
        shell: bash

  # @@ STEP 3: Collect, sort, and repackage all built artifacts with mathematical ordering
  collect-and-sort-artifacts:
    name: Collect and Sort Build Artifacts
    runs-on: ubuntu-latest
    needs: [build-sdist, build-wheels]
    if: always() && (needs.build-sdist.result == 'success' || needs.build-wheels.result == 'success')
    permissions:
      actions: write
      contents: read

    outputs:
      sorted_wheels_count: ${{ steps.sort_artifacts.outputs.sorted_wheels_count }}
      final_artifact_name: ${{ steps.sort_artifacts.outputs.final_artifact_name }}

    steps:
      - name: Download all internal artifacts
        if: inputs.upload_artifacts && github.actor != 'nektos/act'
        uses: actions/download-artifact@v4
        with:
          pattern: ".internal-*"
          path: all-artifacts/

      - name: Set up Python for sorting
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install sorting dependencies
        run: |
          python -m pip install --upgrade pip packaging

      - name: Mathematically sort all wheels and artifacts
        id: sort_artifacts
        run: |
          # || S.S. Create mathematical wheel sorting script
          cat > sort_wheels.py << 'EOF'
          #!/usr/bin/env python3
          """
          Mathematical Wheel Sorting Algorithm

          Sorts wheels by:
          1. Python version (oldest to newest): 3.8 → 3.9 → 3.10 → 3.11 → 3.12 → 3.13
          2. Operating system (alphabetical): linux → macos → windows
          3. Architecture (alphabetical within OS)
          """

          import os
          import re
          import shutil
          from pathlib import Path
          from packaging.version import Version

          def extract_wheel_info(filename):
              """Extract sorting information from wheel filename."""
              # Pattern: package-version-python-abi-platform.whl
              match = re.match(r'^(.+?)-(.+?)-(.+?)-(.+?)-(.+?)\.whl$', filename)
              if not match:
                  return None, None, None, None, None, None

              package, version, python_tag, abi_tag, platform_tag = match.groups()

              # Extract Python version (e.g., cp38, cp39, etc.)
              py_match = re.match(r'cp(\d)(\d+)', python_tag)
              if py_match:
                  major, minor = py_match.groups()
                  python_version = f"{major}.{minor}"
              else:
                  python_version = "99.99"  # Sort unknown versions last

              # Extract OS from platform tag
              if 'linux' in platform_tag.lower():
                  os_name = 'linux'
              elif 'macos' in platform_tag.lower() or 'darwin' in platform_tag.lower():
                  os_name = 'macos'
              elif 'win' in platform_tag.lower():
                  os_name = 'windows'
              else:
                  os_name = 'zzz_unknown'  # Sort unknown OS last

              # Extract architecture
              if 'x86_64' in platform_tag or 'amd64' in platform_tag.lower():
                  arch = 'x86_64'
              elif 'aarch64' in platform_tag or 'arm64' in platform_tag:
                  arch = 'arm64'
              elif 'i386' in platform_tag or 'win32' in platform_tag:
                  arch = 'x86'
              else:
                  arch = 'zzz_unknown'

              return python_version, os_name, arch, platform_tag, python_tag, abi_tag

          def sort_key(filename):
              """Generate sort key for mathematical ordering."""
              if filename.endswith('.tar.gz'):
                  # Source distributions come first
                  return (0, "0.0", "aaa_source", "aaa", filename)

              if not filename.endswith('.whl'):
                  return (2, "99.99", "zzz_other", "zzz", filename)

              python_version, os_name, arch, platform_tag, python_tag, abi_tag = extract_wheel_info(filename)

              if python_version is None:
                  return (2, "99.99", "zzz_unknown", "zzz", filename)

              # Sort key: (file_type, python_version, os_name, arch, filename)
              return (1, Version(python_version), os_name, arch, filename)

          # Find all wheel and source distribution files
          all_files = []
          artifacts_dir = Path('all-artifacts')

          if artifacts_dir.exists():
              for file_path in artifacts_dir.rglob('*'):
                  if file_path.is_file() and (file_path.suffix == '.whl' or file_path.name.endswith('.tar.gz')):
                      all_files.append(file_path)

          # Sort files mathematically
          sorted_files = sorted(all_files, key=lambda f: sort_key(f.name))

          # Create sorted directory structure
          sorted_dir = Path('sorted-artifacts')
          sorted_dir.mkdir(exist_ok=True)

          print("🔢 Mathematical Wheel Sorting Results:")
          print("=" * 50)

          wheel_count = 0
          manifest_lines = []
          seen = set()  # Deduplicate by canonical wheel tag (python_tag, abi_tag, platform_tag)
          idx = 0
          for file_path in sorted_files:
              if file_path.suffix == '.whl':
                  # Deduplicate
                  python_version, os_name, arch, platform_tag, python_tag, abi_tag = extract_wheel_info(file_path.name)
                  if python_version is None:
                      continue
                  key = (python_tag, abi_tag, platform_tag)
                  if key in seen:
                      continue
                  seen.add(key)

                  # Keep file
                  idx += 1
                  dest_path = sorted_dir / file_path.name
                  shutil.copy2(file_path, dest_path)
                  wheel_count += 1
                  manifest_lines.append(f"{idx:02d}. {file_path.name} | Python={python_version} | OS={os_name} | Arch={arch}")
                  print(f"{idx:2d}. {file_path.name}")
                  print(f"    Python: {python_version}, OS: {os_name}, Arch: {arch}")
              elif file_path.name.endswith('.tar.gz'):
                  # Only one sdist should exist, but be safe by deduping on filename
                  idx += 1
                  dest_path = sorted_dir / file_path.name
                  shutil.copy2(file_path, dest_path)
                  manifest_lines.append(f"{idx:02d}. {file_path.name} | Source Distribution")
                  print(f"{idx:2d}. {file_path.name} (source distribution)")

          # Write manifest with deterministic sorted order
          manifest_path = sorted_dir / 'ORDER_MANIFEST.txt'
          with open(manifest_path, 'w', encoding='utf-8') as mf:
              mf.write("Sorted Artifact Order (deterministic)\n")
              mf.write("=" * 40 + "\n")
              for line in manifest_lines:
                  mf.write(line + "\n")

          print(f"\n📊 Total wheels sorted: {wheel_count}")
          print(f"📦 Total files sorted: {len(sorted_files)}")

          # Output for GitHub Actions
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"sorted_wheels_count={wheel_count}\n")
              f.write(f"total_files_count={len(sorted_files)}\n")
          EOF

          # Run the sorting script
          python sort_wheels.py

          # Generate final artifact name
          VERSION="${{ needs.build-sdist.outputs.version || 'unknown' }}"
          SUFFIX="${{ inputs.artifact_name_suffix }}"
          if [ -n "$SUFFIX" ]; then
            FINAL_ARTIFACT_NAME="sorted-wheels-${VERSION}-${SUFFIX}"
          else
            FINAL_ARTIFACT_NAME="sorted-wheels-${VERSION}"
          fi

          echo "final_artifact_name=$FINAL_ARTIFACT_NAME" >> $GITHUB_OUTPUT

          # Clean up
          rm sort_wheels.py


      - name: Append sorted order to summary
        run: |
          echo "## Sorted Artifacts (Deterministic Order)" >> $GITHUB_STEP_SUMMARY
          if [ -f sorted-artifacts/ORDER_MANIFEST.txt ]; then
            cat sorted-artifacts/ORDER_MANIFEST.txt >> $GITHUB_STEP_SUMMARY
          else
            echo "ORDER_MANIFEST.txt not found" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Total wheels: ${{ steps.sort_artifacts.outputs.sorted_wheels_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- Final artifact name: ${{ steps.sort_artifacts.outputs.final_artifact_name }}" >> $GITHUB_STEP_SUMMARY

      - name: Upload sorted artifacts bundle
        if: inputs.upload_artifacts && github.actor != 'nektos/act'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.sort_artifacts.outputs.final_artifact_name }}
          path: sorted-artifacts/
          retention-days: 90
          compression-level: 6

      - name: Delete internal artifacts (cleanup)
        if: inputs.upload_artifacts && github.actor != 'nektos/act'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          if ! command -v gh >/dev/null 2>&1; then
            echo "gh CLI not available; skipping cleanup"
            exit 0
          fi
          echo "Cleaning up internal artifacts (.internal-*)..."
          IDS=$(gh api -X GET repos/$REPO/actions/artifacts?per_page=100 --jq '.artifacts[] | select(.name | startswith(".internal-")) | .id')
          if [ -n "$IDS" ]; then
            for ID in $IDS; do
              echo "Deleting artifact ID $ID"
              gh api -X DELETE repos/$REPO/actions/artifacts/$ID || true
            done
          else
            echo "No internal artifacts found to delete."
          fi
